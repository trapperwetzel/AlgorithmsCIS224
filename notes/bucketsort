Bucket Sort:

	The running time of any comparison based-algorithm that sorts an (n) element sequence is (nlogn) in the worst-case
	O(nlogn) is the best possible time complexity for a generic sequence. 
	
	The only way to get a better run time is if we have more information; which is where bucketsort comes in. 
	
	Define Bucket Sort:
		Suppose we are sorting key values pairs where the keys are intergers. Note: this is probably our "more information".

		Now, Suppose we have a list named S, with n entries. Keys in the range for N >= 2. And we want to sort by keys. 
		We would need to create N "buckets" That is, B[0], B[1], B[N-1]...
		--------------------------------------------------------------------
		So lets say we have a something like [(1,a),(1,c),(2,b),(2,c),(5,a)]
		We would see that we need to make 6 buckets, why 6? because 5 is the max number. And remember 0 based indexing so we would end up making:
		Bucket[0], Bucket[1], Bucket[2], Bucket[3], Bucket[4], Bucket[5] 
		So we got the amount of buckets we need to make, and we made the buckets. 
		----------------------------------------------------------------------------------------------------------------------------------------
		So now we have to loop over our inital sequence, and fill our empty buckets. using something like:
		for(const element of sequence) { 
			buckets[element[0].push(element) 
		}
		This would make it so each bucket is filled properly because element[0] will return the key that corresponds to the bucket. 
		Using that loop, let's do the first iteration of our sequence earlier..
		Step 1: What is buckets[element[0]] ?
			- buckets[element[0]] = 1 because we are going inside the first tuple of our sequence (1,a)
			- And inside that first tuple (1,a) we take the 0 index which is 1.
			- This makes it so we can push to our buckets array properly because we now know that element[0] of the first iteration is 1.
			- So we will push element (1,a) into bucket[1]. 
		Step 2: Repeat until all buckets are filled.  
		----------------------------------------------------------------------------------------------------------------------------------------
		Now onto the final part of bucket sort, adding the elements back to the original sequence in the bucket order. 
			let position = 0; 
			for(const bucket in buckets){
		    		for(const element in bucket){
					sequence[position].push(element);
					position++;
				}
			}	
